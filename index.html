<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Candlelight Christmas</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- MediaPipe Global Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300;400&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505; /* å›å½’æ·±é»‘èƒŒæ™¯ä»¥çªæ˜¾å½©è‰² */
            font-family: 'Lato', sans-serif;
            color: #e2e8f0;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .ui-element {
            pointer-events: auto;
        }

        h1 {
            font-family: 'Cinzel', serif;
            text-shadow: 0 0 30px rgba(138, 43, 226, 0.8);
            color: #fff;
        }

        .glass-panel {
            background: rgba(20, 10, 30, 0.75); /* å¾®ç´«è‰²çš„æ·±è‰²ç»ç’ƒèƒŒæ™¯ */
            backdrop-filter: blur(16px);
            border: 1px solid rgba(138, 43, 226, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
        }
        
        .instruction-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            border: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Hidden Video for MediaPipe -->
    <video id="input-video" style="display:none;" playsinline></video>

    <!-- UI Overlay -->
    <div id="ui-layer" class="flex flex-col justify-between p-6">
        
        <!-- Header -->
        <div class="flex justify-between items-start">
            <div class="glass-panel p-6 rounded-xl max-w-md transition-all duration-700 transform translate-y-0 opacity-100" id="intro-panel">
                <h1 class="text-3xl text-purple-200 mb-2 font-bold tracking-widest">Merry Christmas</h1>
                <p class="text-purple-100/80 text-xs mb-6 leading-relaxed border-l-2 border-purple-500 pl-3">
                    è¯·å¼€å¯æ‘„åƒå¤´ï¼Œç”¨æ‰‹åŠ¿å”¤é†’ç»šä¸½é­”æ³•
                </p>
                
                <div class="space-y-4">
                    <div class="flex items-center gap-4">
                        <div class="instruction-icon bg-purple-900/40 text-purple-200 border-purple-500/30">
                            âœŠ
                        </div>
                        <div>
                            <p class="text-purple-100 text-sm font-bold uppercase tracking-wide">æ¡æ‹³ (Fist)</p>
                            <p class="text-purple-100/60 text-xs">å‡èšè‰²å½©</p>
                        </div>
                    </div>
                    <div class="flex items-center gap-4">
                        <div class="instruction-icon bg-white/10 text-white border-white/30">
                            ğŸ–
                        </div>
                        <div>
                            <p class="text-white text-sm font-bold uppercase tracking-wide">å¼ å¼€æ‰‹ (Open)</p>
                            <p class="text-white/60 text-xs">é›ªèˆæ¼«å¤©</p>
                        </div>
                    </div>
                    <div class="flex items-center gap-4">
                        <div class="instruction-icon bg-red-900/40 text-red-200 border-red-500/30">
                            ğŸ‘Œ
                        </div>
                        <div>
                            <p class="text-red-100 text-sm font-bold uppercase tracking-wide">æåˆ (Pinch)</p>
                            <p class="text-red-100/60 text-xs">ç‚¹ç‡ƒçƒ›å…‰</p>
                        </div>
                    </div>
                </div>

                <button id="start-btn" class="ui-element mt-8 w-full py-3 bg-gradient-to-r from-purple-700 via-violet-600 to-purple-800 hover:from-purple-600 hover:to-purple-700 text-white font-serif tracking-widest text-sm uppercase rounded shadow-lg shadow-black/50 transition-all border border-purple-400/30">
                    å¼€å¯ç»šä¸½åº†å…¸
                </button>
                <p id="loading-text" class="hidden text-xs text-center mt-3 text-purple-400 animate-pulse tracking-wide">æ­£åœ¨æ³¨å…¥é­”æ³•...</p>
            </div>

            <!-- Upload Control -->
            <div class="glass-panel p-4 rounded-full ui-element hover:bg-purple-900/30 transition-all cursor-pointer group active:scale-95" onclick="document.getElementById('photo-upload').click()">
                <div class="flex flex-col items-center justify-center w-12 h-12">
                    <span class="text-2xl text-purple-400 group-hover:text-purple-200 transition-colors">ğŸ“·</span>
                </div>
                <input type="file" id="photo-upload" multiple accept="image/*, video/mp4, video/webm, video/ogg" class="hidden">
            </div>
        </div>

        <!-- Feedback HUD -->
        <div class="flex flex-col items-center mb-8 gap-2">
            <div id="gesture-feedback" class="glass-panel px-10 py-3 rounded-full text-purple-300 font-serif tracking-widest text-sm opacity-0 transition-opacity duration-300">
                SYSTEM STANDBY
            </div>
            <p class="text-xs text-purple-300/50 font-mono opacity-50 uppercase">Use Index Finger to Aim</p>
        </div>
    </div>

    <!-- Main Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            particleCount: 1600,
            colors: {
                base: 0xB39DDB,     // Light Lavender/Violet (Lighter than BlueViolet)
                highlight: 0xFFFFFF, // White for Spheres
                candleBody: 0xB22222, // Firebrick Red for Candle Body
                candleFlame: 0xFFD700 // Gold for Flame
            },
            treeHeight: 35,
            treeRadius: 14,
            camZ: 45
        };

        // --- State Management ---
        const STATE = {
            mode: 'TREE', 
            handDetected: false,
            handPosition: { x: 0, y: 0 },   // Palm
            cursorPosition: { x: 0, y: 0 }, // Index Tip
            rotation: 0,
            targetRotation: 0,
            photos: [],
            lastGesture: 'OPEN',
            gestureFrameCount: 0,
            isPinching: false 
        };

        // --- Global Variables ---
        let camera, scene, renderer, composer, bloomPass;
        let particles = []; 
        let photoMeshes = [];
        let cursorMesh;
        let clock = new THREE.Clock();
        let raycaster = new THREE.Raycaster();
        let focusedPhoto = null;
        let hoveredPhoto = null;
        let photoGroups = [];
        let loader = new THREE.TextureLoader();
        let maxAnisotropy = 1;
        
        // --- Initialization ---
        const init = () => {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.015);
            scene.background = new THREE.Color(0x050505);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, CONFIG.camZ);

            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                powerPreference: "high-performance",
                logarithmicDepthBuffer: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3; // Increased for mobile visibility
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
            container.appendChild(renderer.domElement);

            // Post Processing
            const renderScene = new RenderPass(scene, camera);
            
            // Bloom - Adjusted for Candle Glow
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.7; // Lower threshold slightly to catch candle flames
            bloomPass.strength = 2.2; 
            bloomPass.radius = 0.6;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Lighting - Brightened for mobile screens
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.15); // Increased from 0.05
            scene.add(ambientLight);
            
            // Spotlight - Warm purple/orange mix - Boosted
            const spotLight = new THREE.SpotLight(0xa855f7, 3800); // Increased from 3000
            spotLight.position.set(20, 50, 20);
            spotLight.decay = 2;
            spotLight.distance = 200;
            scene.add(spotLight);
            
            // Warm rim light for candles - Boosted
            const rimLight = new THREE.SpotLight(0xff4500, 2200); // Increased from 1500
            rimLight.position.set(-20, 20, -20);
            scene.add(rimLight);

            // Objects
            createParticles();
            createDefaultPhotos();
            createCursor();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            renderer.setAnimationLoop(animate);
        };

        const createCursor = () => {
            const geometry = new THREE.RingGeometry(0.8, 1, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide,
                depthTest: false 
            });
            cursorMesh = new THREE.Mesh(geometry, material);
            cursorMesh.renderOrder = 999;
            cursorMesh.visible = false;
            scene.add(cursorMesh);
        };

        // --- Particle System (Updated) ---
        const createParticles = () => {
            // 1. Highlight (Spheres) - White
            const matHighlight = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.highlight, 
                metalness: 0.9, 
                roughness: 0.1, 
                emissive: 0xffffff,
                emissiveIntensity: 1.5
            });
            
            // 2. Base (Diamonds) - Violet Crystal
            // å‡çº§ä¸º MeshPhysicalMaterial ä»¥è·å¾—çœŸå®çš„æ°´æ™¶ç»ç’ƒè´¨æ„Ÿ
            const matBase = new THREE.MeshPhysicalMaterial({ 
                color: CONFIG.colors.base, 
                metalness: 0.1,         // ä½é‡‘å±åº¦ï¼Œæ›´åƒæ™¶ä½“è€Œéé‡‘å±
                roughness: 0.02,        // æåº¦å…‰æ»‘ï¼Œäº§ç”Ÿé”åˆ©çš„é«˜å…‰
                transmission: 0.92,     // é«˜é€å…‰ç‡ï¼Œå…‰çº¿å¯ä»¥ç©¿é€
                thickness: 1.5,         // æ¨¡æ‹Ÿæ™¶ä½“åšåº¦ï¼Œäº§ç”Ÿå†…éƒ¨æŠ˜å°„
                ior: 1.7,               // æŠ˜å°„ç‡ (Index of Refraction)ï¼Œ1.5-1.7 æ¥è¿‘æ°´æ™¶/å®çŸ³
                emissive: 0x7B68EE,     // Lighter emissive (MediumSlateBlue) instead of Indigo
                emissiveIntensity: 0.2, // é™ä½è‡ªå‘å…‰ï¼Œè®©é€å…‰æ•ˆæœæ›´æ˜æ˜¾
                flatShading: true,      // ä¿æŒæ£±è§’åˆ†æ˜ï¼Œåƒåˆ‡å‰²è¿‡çš„å®çŸ³
                transparent: true,
                opacity: 1.0,           // åœ¨ä½¿ç”¨ transmission æ—¶ï¼Œopacity é€šå¸¸ä¿æŒé«˜å€¼
                side: THREE.DoubleSide
            });
            
            // 3. Candle Body (Cylinders) - Red Wax
            const matCandleBody = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.candleBody, 
                metalness: 0.3, 
                roughness: 0.4, 
                emissive: 0x800000, 
                emissiveIntensity: 0.5 
            });

            // 4. Candle Flame (Cones) - Bright Fire
            const matCandleFlame = new THREE.MeshStandardMaterial({
                color: 0xffaa00,
                emissive: 0xff5500,
                emissiveIntensity: 4.0, 
                toneMapped: false
            });

            const geomSphere = new THREE.SphereGeometry(0.35, 12, 12);
            
            // ä½¿ç”¨å…«é¢ä½“æ¥æ¨¡æ‹Ÿè±å½¢ (Diamond Shape)
            const geomDiamond = new THREE.OctahedronGeometry(0.4, 0); 
            
            const geomCyl = new THREE.CylinderGeometry(0.12, 0.12, 0.7, 8); 
            
            const geomFlame = new THREE.ConeGeometry(0.08, 0.3, 8); 
            geomFlame.translate(0, 0.5, 0); 
            
            const meshHighlight = new THREE.InstancedMesh(geomSphere, matHighlight, 400); 
            const meshBase = new THREE.InstancedMesh(geomDiamond, matBase, 800); 
            
            const meshCandleBody = new THREE.InstancedMesh(geomCyl, matCandleBody, 150);  
            const meshCandleFlame = new THREE.InstancedMesh(geomFlame, matCandleFlame, 150);

            scene.add(meshHighlight);
            scene.add(meshBase);
            scene.add(meshCandleBody);
            scene.add(meshCandleFlame);

            // Generic Distribute
            const distribute = (mesh, offsetIndex, type) => {
                const count = mesh.count;
                const dummy = new THREE.Object3D();
                let validCount = 0;

                for (let i = 0; i < count; i++) {
                    const t = i / count;
                    
                    // --- Logic for Reducing Density at Top (Violet Diamonds) ---
                    if (type === 'diamond') {
                        // If we are in the top 25% of the tree
                        if (t > 0.75) {
                            // Skip 70% of the particles in this region
                            if (Math.random() < 0.7) {
                                continue; 
                            }
                        }
                    }

                    const y = -12 + t * CONFIG.treeHeight;
                    const radius = (1 - t) * CONFIG.treeRadius;
                    const angle = i * 2.399 + offsetIndex;
                    
                    const tx = Math.cos(angle) * radius + (Math.random()-0.5);
                    const tz = Math.sin(angle) * radius + (Math.random()-0.5);
                    const cx = (Math.random() - 0.5) * 60;
                    const cy = (Math.random() - 0.5) * 40;
                    const cz = (Math.random() - 0.5) * 30;

                    dummy.position.set(tx, y, tz);
                    
                    const baseS = Math.random() * 0.5 + 0.5;
                    
                    // é’ˆå¯¹è±å½¢è¿›è¡Œæ‹‰é•¿å¤„ç†
                    if (type === 'diamond') {
                        // X, Z è½´ç¼©çª„, Y è½´æ‹‰é•¿ -> å½¢æˆç«–ç€çš„è±å½¢
                        dummy.scale.set(baseS * 0.6, baseS * 1.4, baseS * 0.6);
                    } else {
                        dummy.scale.setScalar(baseS);
                    }

                    dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(validCount, dummy.matrix);

                    particles.push({
                        mesh: mesh,
                        index: validCount,
                        treePos: new THREE.Vector3(tx, y, tz),
                        chaosPos: new THREE.Vector3(cx, cy, cz),
                        currentPos: new THREE.Vector3(tx, y, tz),
                        wobbleOffset: Math.random() * 100,
                        wobbleSpeed: Math.random() * 0.5 + 0.5,
                        baseScale: dummy.scale.clone(),
                        isFlame: false 
                    });
                    
                    validCount++;
                }
                mesh.count = validCount; 
            };

            // Candle Specific Distribute
            const distributeCandles = () => {
                const count = 120;
                
                meshCandleBody.count = count;
                meshCandleFlame.count = count;

                const dummy = new THREE.Object3D();

                for(let i=0; i<count; i++) {
                    const t = i / count;
                    const y = -12 + t * CONFIG.treeHeight;
                    const radius = (1 - t) * CONFIG.treeRadius;
                    const angle = i * 2.399 + 2; 

                    const tx = Math.cos(angle) * radius + (Math.random()-0.5);
                    const tz = Math.sin(angle) * radius + (Math.random()-0.5);
                    
                    const cx = (Math.random() - 0.5) * 60;
                    const cy = (Math.random() - 0.5) * 40;
                    const cz = (Math.random() - 0.5) * 30;

                    // 1. Candle Body
                    dummy.position.set(tx, y, tz);
                    dummy.scale.setScalar(1.0);
                    dummy.rotation.set(0, Math.random()*Math.PI, 0); 
                    dummy.updateMatrix();
                    meshCandleBody.setMatrixAt(i, dummy.matrix);

                    particles.push({
                        mesh: meshCandleBody,
                        index: i,
                        treePos: new THREE.Vector3(tx, y, tz),
                        chaosPos: new THREE.Vector3(cx, cy, cz),
                        currentPos: new THREE.Vector3(tx, y, tz),
                        wobbleOffset: Math.random() * 100,
                        wobbleSpeed: Math.random() * 0.5 + 0.5,
                        baseScale: new THREE.Vector3(1,1,1),
                        isFlame: false
                    });

                    // 2. Candle Flame
                    meshCandleFlame.setMatrixAt(i, dummy.matrix);
                    
                    particles.push({
                        mesh: meshCandleFlame,
                        index: i,
                        treePos: new THREE.Vector3(tx, y, tz),
                        chaosPos: new THREE.Vector3(cx, cy + 1, cz), 
                        currentPos: new THREE.Vector3(tx, y, tz),
                        wobbleOffset: Math.random() * 100,
                        wobbleSpeed: Math.random() * 2.0 + 2.0, 
                        baseScale: new THREE.Vector3(1,1,1),
                        isFlame: true 
                    });
                }
            };

            distribute(meshHighlight, 0, 'sphere'); 
            distribute(meshBase, 1, 'diamond'); 
            distributeCandles();                    
        };

        // --- Photo/Video System ---
        const createPhoto = (texture, index, videoElement = null) => {
            const group = new THREE.Group();
            
            texture.anisotropy = maxAnisotropy;
            texture.minFilter = THREE.LinearFilter; 
            texture.magFilter = THREE.LinearFilter;
            
            let aspect = 0.8;
            if (videoElement) {
                if(videoElement.videoWidth) aspect = videoElement.videoWidth / videoElement.videoHeight;
            } else if (texture.image && texture.image.width) {
                aspect = texture.image.width / texture.image.height;
            }
            
            const width = 5;
            const height = width / aspect;

            const pGeo = new THREE.PlaneGeometry(width, height);
            const pMat = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1
            });
            const pMesh = new THREE.Mesh(pGeo, pMat);
            
            pMesh.position.z = 0.08; 
            pMesh.name = "photo_surface"; 
            
            // Frame Plane - Silver/White Frame to match new theme
            const fWidth = width + 0.8; 
            const fHeight = height + 2.0; 
            const fGeo = new THREE.PlaneGeometry(fWidth, fHeight);
            
            const fMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                metalness: 0.8,
                roughness: 0.2,
                side: THREE.DoubleSide 
            });
            const fMesh = new THREE.Mesh(fGeo, fMat);
            
            pMesh.position.y = (fHeight - height) / 2 - 0.5;

            group.add(fMesh);
            group.add(pMesh);

            const cx = (Math.random() - 0.5) * 40;
            const cy = (Math.random() - 0.5) * 30;
            const cz = (Math.random() - 0.5) * 20;

            group.userData = {
                chaosPos: new THREE.Vector3(cx, cy, cz),
                treePos: new THREE.Vector3(0, 15, 0),
                velocity: new THREE.Vector3((Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02, 0),
                video: videoElement 
            };
            
            group.scale.set(0,0,0);
            
            scene.add(group);
            photoMeshes.push(group);
            photoGroups.push(group);
        };

        const createDefaultPhotos = () => {
            const defaultContent = [
                { type: 'image', url: 'https://images.unsplash.com/photo-1543589077-47d81606c1bf?auto=format&fit=crop&w=600&q=80' },
                { type: 'image', url: 'https://images.unsplash.com/photo-1576919228636-1e796e624c9f?auto=format&fit=crop&w=600&q=80' },
                { type: 'image', url: 'https://images.unsplash.com/photo-1512474932049-782abb8be2e9?auto=format&fit=crop&w=600&q=80' },
                { type: 'image', url: 'https://images.unsplash.com/photo-1482517967863-00e15c9b44be?auto=format&fit=crop&w=600&q=80' },
                { type: 'image', url: 'https://images.unsplash.com/photo-1545629173-138374a27453?auto=format&fit=crop&w=600&q=80' }
            ];

            defaultContent.forEach((item, i) => {
                if (item.type === 'video') {
                    const video = document.createElement('video');
                    video.src = item.url;
                    video.loop = true;
                    video.muted = true; 
                    video.playsInline = true;
                    video.crossOrigin = "anonymous";
                    video.onloadedmetadata = () => {
                        const texture = new THREE.VideoTexture(video);
                        texture.colorSpace = THREE.SRGBColorSpace;
                        createPhoto(texture, i, video);
                    };
                    video.onerror = () => {
                        createFallbackCard(i, "Video Error");
                    }
                } else {
                    loader.load(item.url, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace; 
                        createPhoto(texture, i);
                    }, undefined, () => {
                        createFallbackCard(i, "Magic");
                    });
                }
            });
        };

        const createFallbackCard = (index, text) => {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#8A2BE2'; ctx.fillRect(0,0,512,512); // Violet background
            ctx.fillStyle = '#fff'; 
            ctx.font = '60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, 256, 256);
            const t = new THREE.CanvasTexture(canvas);
            t.colorSpace = THREE.SRGBColorSpace;
            createPhoto(t, index);
        };

        // --- Logic Update ---
        const updateState = (delta, time) => {
            
            const targetBloomStrength = (STATE.mode === 'FOCUS') ? 0.3 : 2.2;
            bloomPass.strength += (targetBloomStrength - bloomPass.strength) * 4.0 * delta;

            const dummy = new THREE.Object3D();
            
            // 1. Cursor & Camera Logic
            hoveredPhoto = null; // Reset hover

            if (STATE.mode === 'EXPLODE' || STATE.mode === 'FOCUS') {
                if (STATE.handDetected) {
                    // Cursor from Index Tip
                    raycaster.setFromCamera(STATE.cursorPosition, camera);
                    
                    const cursorDist = 20;
                    const cursorPos = new THREE.Vector3()
                        .copy(raycaster.ray.direction)
                        .multiplyScalar(cursorDist)
                        .add(raycaster.ray.origin);
                        
                    cursorMesh.position.copy(cursorPos);
                    cursorMesh.lookAt(camera.position);
                    cursorMesh.visible = true;

                    // Hover Detection
                    const intersects = raycaster.intersectObjects(photoGroups, true); 
                    if (intersects.length > 0) {
                        let target = intersects[0].object;
                        while(target.parent && !photoMeshes.includes(target)) {
                            target = target.parent;
                        }
                        if (photoMeshes.includes(target)) {
                            hoveredPhoto = target;
                        }
                    }

                    if (STATE.isPinching) {
                        cursorMesh.scale.set(0.5, 0.5, 0.5);
                        cursorMesh.material.color.set(0xff0000); // Red on pinch
                    } else {
                        cursorMesh.scale.set(1, 1, 1);
                        cursorMesh.material.color.set(0xffffff); // White
                    }

                    // Rotation from Palm Center
                    if (STATE.mode === 'EXPLODE') {
                        // Wide rotation
                        const targetRot = STATE.handPosition.x * 2.0; 
                        STATE.rotation += (targetRot - STATE.rotation) * 2.0 * delta;
                        
                        // Adaptive Camera
                        const camDist = getResponsiveCamZ();
                        camera.position.x = Math.sin(STATE.rotation) * camDist;
                        camera.position.z = Math.cos(STATE.rotation) * camDist;
                        camera.lookAt(0, 0, 0);
                    }
                } else {
                    cursorMesh.visible = false;
                }
            } else {
                STATE.rotation += delta * 0.2;
                const camDist = getResponsiveCamZ();
                camera.position.x = Math.sin(STATE.rotation) * camDist;
                camera.position.z = Math.cos(STATE.rotation) * camDist;
                camera.lookAt(0, 5, 0);
                cursorMesh.visible = false;
            }

            const lerpSpeed = 4.0 * delta;
            particles.forEach(p => {
                let target = (STATE.mode === 'TREE') ? p.treePos : p.chaosPos;
                p.currentPos.lerp(target, lerpSpeed);
                
                // Base wobble
                let wobble = Math.sin(time * p.wobbleSpeed + p.wobbleOffset) * 0.2;
                
                dummy.position.copy(p.currentPos);
                
                // Add flicker to flames in TREE mode
                if (p.isFlame && STATE.mode === 'TREE') {
                    // Random flicker intensity
                    const flicker = Math.sin(time * 15 + p.wobbleOffset) * 0.1 + Math.cos(time * 25) * 0.1;
                    const scaleFlicker = 1.0 + flicker * 0.3;
                    dummy.scale.set(scaleFlicker, scaleFlicker, scaleFlicker);
                } else {
                    const scaleTarget = (STATE.mode === 'TREE') ? 1.0 : 0.6;
                    dummy.scale.setScalar(scaleTarget);
                }

                if (STATE.mode !== 'TREE') dummy.position.y += wobble;
                
                dummy.lookAt(camera.position); 
                
                // Keep Candles Upright in TREE mode
                if (STATE.mode === 'TREE' && !p.isFlame) {
                     dummy.rotation.set(0,0,0);
                }
                
                dummy.updateMatrix();
                p.mesh.setMatrixAt(p.index, dummy.matrix);
            });
            scene.children.filter(c => c.isInstancedMesh).forEach(m => m.instanceMatrix.needsUpdate = true);

            photoMeshes.forEach(group => {
                if (STATE.mode === 'TREE') {
                    group.scale.lerp(new THREE.Vector3(0,0,0), lerpSpeed);
                    group.position.lerp(group.userData.treePos, lerpSpeed);
                    if(group.userData.video) {
                        group.userData.video.muted = true; 
                        group.userData.video.play(); 
                    }
                } else {
                    group.visible = true;
                    if (STATE.mode === 'FOCUS' && group === focusedPhoto) {
                        const frontPos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(12));
                        group.position.lerp(frontPos, lerpSpeed * 3);
                        group.lookAt(camera.position);
                        group.scale.lerp(new THREE.Vector3(1.5, 1.5, 1.5), lerpSpeed);
                    } else {
                        let target = group.userData.chaosPos.clone();
                        
                        let scaleTarget = 1.0;
                        if (STATE.mode === 'FOCUS') {
                            scaleTarget = 0.5;
                        } else if (group === hoveredPhoto) {
                            scaleTarget = 1.15;
                            const dir = camera.position.clone().sub(target).normalize();
                            target = target.clone().add(dir.multiplyScalar(2));
                        }

                        group.scale.lerp(new THREE.Vector3(scaleTarget, scaleTarget, scaleTarget), lerpSpeed);
                        target.y += Math.sin(time + group.id) * 0.5;
                        group.position.lerp(target, lerpSpeed);
                        group.lookAt(camera.position);
                    }
                }
            });
        };

        const animate = () => {
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            updateState(delta, time);
            composer.render();
        };

        const getResponsiveCamZ = () => {
            const aspect = window.innerWidth / window.innerHeight;
            if (aspect < 1.0) {
                return CONFIG.camZ / aspect * 0.8;
            }
            return CONFIG.camZ;
        };

        const updateCameraPosition = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            camera.position.z = getResponsiveCamZ();
        };

        const onWindowResize = () => {
            updateCameraPosition();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        };

        const videoElement = document.getElementById('input-video');
        const startBtn = document.getElementById('start-btn');
        const feedbackEl = document.getElementById('gesture-feedback');
        const loadingText = document.getElementById('loading-text');
        
        startBtn.addEventListener('click', async () => {
            startBtn.disabled = true;
            startBtn.classList.add('opacity-50');
            loadingText.classList.remove('hidden');

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });
            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 640, height: 480
            });
            await cameraUtils.start();

            document.getElementById('intro-panel').classList.add('opacity-0');
            setTimeout(()=> document.getElementById('intro-panel').style.display = 'none', 700);
            feedbackEl.style.opacity = '1';
        });

        const onHandsResults = (results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.handDetected = true;
                const lm = results.multiHandLandmarks[0];
                
                // Palm for Rotation
                let palmX = (1 - lm[9].x) * 2 - 1; 
                STATE.handPosition.x = Math.max(-1, Math.min(1, palmX * 1.5)); 

                // Index for Cursor
                let tipX = (1 - lm[8].x) * 2 - 1; 
                let tipY = (1 - lm[8].y) * 2 - 1;
                tipX *= 1.3; tipY *= 1.3; tipY += 0.2; 
                STATE.cursorPosition.x = Math.max(-1, Math.min(1, tipX));
                STATE.cursorPosition.y = Math.max(-1, Math.min(1, tipY));

                processGesture(lm);
            } else {
                STATE.handDetected = false;
                STATE.gestureFrameCount = 0;
                STATE.isPinching = false;
                updateFeedback("SEARCHING HAND...", "gray");
            }
        };

        const processGesture = (lm) => {
            const dist = (i, j) => Math.sqrt(
                Math.pow(lm[i].x - lm[j].x, 2) + 
                Math.pow(lm[i].y - lm[j].y, 2) + 
                Math.pow(lm[i].z - lm[j].z, 2)
            );

            const scale = dist(0, 9);
            if (scale < 0.02) return;

            const dThumbIndex = dist(4, 8) / scale;
            const dMiddle = dist(12, 0) / scale;
            const dRing = dist(16, 0) / scale;
            const dPinky = dist(20, 0) / scale;
            const otherFingersExt = (dMiddle + dRing + dPinky) / 3;

            let detected = STATE.lastGesture;

            if (otherFingersExt < 0.85) {
                detected = 'FIST';
            } else {
                const pinchThreshold = STATE.isPinching ? 0.50 : 0.26;
                if (dThumbIndex < pinchThreshold) {
                    detected = 'PINCH';
                } else {
                    detected = 'OPEN';
                }
            }

            if (detected === STATE.lastGesture) {
                STATE.gestureFrameCount++;
            } else {
                STATE.gestureFrameCount = 0;
                STATE.lastGesture = detected;
            }

            if (STATE.gestureFrameCount > 3) {
                executeState(detected);
            }
        };

        const executeState = (gesture) => {
            if (gesture === 'PINCH') {
                STATE.isPinching = true;
                if (STATE.mode !== 'TREE') {
                    if (hoveredPhoto) {
                        let target = hoveredPhoto;
                        if (focusedPhoto !== target) {
                            if (focusedPhoto && focusedPhoto.userData.video) focusedPhoto.userData.video.muted = true;
                            focusedPhoto = target;
                            if (focusedPhoto.userData.video) {
                                focusedPhoto.userData.video.muted = false;
                                focusedPhoto.userData.video.play().catch(e => {
                                    console.warn("Autoplay blocked", e);
                                    focusedPhoto.userData.video.muted = true;
                                    focusedPhoto.userData.video.play();
                                });
                            }
                        }
                        STATE.mode = 'FOCUS';
                    }
                }
                updateFeedback("PINCH: GRAB MEMORY", "red");
            } else if (gesture === 'FIST') {
                STATE.isPinching = false;
                STATE.mode = 'TREE';
                if(focusedPhoto && focusedPhoto.userData.video) focusedPhoto.userData.video.muted = true;
                focusedPhoto = null;
                updateFeedback("FIST: ASSEMBLE", "purple");
            } else if (gesture === 'OPEN') {
                STATE.isPinching = false;
                if (STATE.mode === 'FOCUS') {
                    STATE.mode = 'EXPLODE';
                    if(focusedPhoto && focusedPhoto.userData.video) focusedPhoto.userData.video.muted = true;
                    focusedPhoto = null;
                } else if (STATE.mode === 'TREE') {
                    STATE.mode = 'EXPLODE';
                }
                updateFeedback("OPEN: CHAOS MODE", "white");
            }
        };

        const updateFeedback = (text, colorKey) => {
            const colors = {
                red: "text-red-300 border-red-500/50 shadow-red-500/30",
                purple: "text-purple-300 border-purple-500/50 shadow-purple-500/30",
                white: "text-white border-white/50 shadow-white/30",
                gray: "text-gray-500 border-gray-600/20 shadow-none"
            };
            feedbackEl.textContent = text;
            feedbackEl.className = `glass-panel px-10 py-3 rounded-full font-serif tracking-widest text-sm transition-all duration-300 border shadow-lg ${colors[colorKey]}`;
        };

        document.getElementById('photo-upload').addEventListener('change', (e) => {
            const files = e.target.files;
            if(!files.length) return;
            
            photoMeshes.forEach(m => scene.remove(m));
            photoMeshes = [];
            photoGroups = [];
            
            Array.from(files).forEach((file, i) => {
                const url = URL.createObjectURL(file);
                if (file.type.startsWith('video/')) {
                    const video = document.createElement('video');
                    video.src = url; video.loop = true; video.muted = true; video.playsInline = true; video.crossOrigin = "anonymous";
                    video.onloadedmetadata = () => {
                        const texture = new THREE.VideoTexture(video); texture.colorSpace = THREE.SRGBColorSpace;
                        createPhoto(texture, i, video); video.play();
                    };
                    video.load();
                } else {
                    loader.load(url, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace; 
                        createPhoto(texture, i);
                        URL.revokeObjectURL(url);
                    }, undefined, (err) => {
                        console.error('Error loading image', err);
                    });
                }
            });
        });

        init();
    </script>
</body>
</html>
